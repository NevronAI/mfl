#!/usr/bin/python3
import numpy as np

from metisfl.proto.model_pb2 import Model
from metisfl.controller.aggregation.TensorOps import TensorOps

class FederatedAverage:
    """
    Compute average of predictions generated by federated models.
    """
    def __init__(self):
        self.model = Model()

    def Aggregate(self, pairs):

        sample_model = pairs[0][0][0]

        self.model.tensors.CopyFrom(sample_model.tensors)

        total_tensors = self.model.tensors_size()

        for var_idx in range(total_tensors):
            var_num_values = self.model.tensors[var_idx].length()

            aggregated_tensor = self.AggregateTensorAtIndex(pairs, var_idx, var_num_values)
            serialized_tensor = TensorOps.serialize_tensor(aggregated_tensor)
            serialized_tensor_str = serialized_tensor.tostring()

            self.model.tensors[var_idx].value = serialized_tensor_str

        return self.model

    def Reset(self):
        pass

    def AddTensors(self, tensor_left, tensor_spec_right, scaling_factor_right):
        t2_r = np.fromstring(tensor_spec_right.value, dtype=float)
        t2_r *= scaling_factor_right

        tensor_left += t2_r

    def AggregateTensorAtIndex(self, pairs, var_idx, var_num_values):
        aggregated_tensor = np.zeros(var_num_values)

        for pair in pairs:
            local_model = pair[0][0]

            if not local_model.encrypted:
                local_tensor = local_model.tensors[var_idx]
                self.AddTensors(aggregated_tensor, local_tensor, pair[0][1])
            else:
                raise RuntimeError("Cannot aggregate encrypted tensors using Federated Average.")
        
        return aggregated_tensor
